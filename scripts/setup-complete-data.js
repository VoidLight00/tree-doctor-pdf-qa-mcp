#!/usr/bin/env node

/**
 * ÎÇòÎ¨¥ÏùòÏÇ¨ PDF Q&A MCP - ÏôÑÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï Ïä§ÌÅ¨Î¶ΩÌä∏
 * Îã§Î•∏ PCÏóêÏÑúÎèÑ Î™®Îì† Í∏∞Ï∂úÎ¨∏Ï†úÏôÄ ÍµêÏû¨Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù ÏÑ§Ï†ï
 */

const fs = require('fs').promises;
const path = require('path');
const sqlite3 = require('sqlite3').verbose();

class TreeDoctorDataSetup {
  constructor() {
    this.dbPath = path.join(__dirname, '..', 'tree-doctor-pdf-qa.db');
    this.dataDir = path.join(__dirname, '..', 'data');
    this.structuredDir = path.join(this.dataDir, 'structured');
    this.db = null;
  }

  async initialize() {
    console.log('üå≥ ÎÇòÎ¨¥ÏùòÏÇ¨ MCP Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî ÏãúÏûë...\n');
    
    // Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞
    this.db = new sqlite3.Database(this.dbPath);
    
    // Ïä§ÌÇ§Îßà ÏÉùÏÑ±
    await this.createSchema();
    
    // Îç∞Ïù¥ÌÑ∞ Î°úÎìú
    await this.loadAllData();
    
    console.log('\n‚úÖ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!');
  }

  async createSchema() {
    console.log('üìã Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà ÏÉùÏÑ±...');
    
    const schemaPath = path.join(__dirname, '..', 'sql', 'exam-schema.sql');
    const schema = await fs.readFile(schemaPath, 'utf-8');
    
    return new Promise((resolve, reject) => {
      this.db.exec(schema, (err) => {
        if (err) {
          console.error('‚ùå Ïä§ÌÇ§Îßà ÏÉùÏÑ± Ïã§Ìå®:', err);
          reject(err);
        } else {
          console.log('‚úÖ Ïä§ÌÇ§Îßà ÏÉùÏÑ± ÏôÑÎ£å');
          resolve();
        }
      });
    });
  }

  async loadAllData() {
    console.log('\nüìö Í∏∞Ï∂úÎ¨∏Ï†ú Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë...');
    
    // Í∏∞Ï∂úÎ¨∏Ï†ú Î°úÎìú
    await this.loadExamQuestions();
    
    // ÍµêÏû¨ Ï†ïÎ≥¥ Î°úÎìú
    await this.loadTextbookInfo();
    
    // Í≤ÄÏÉâ Ïù∏Îç±Ïä§ ÏÉùÏÑ±
    await this.createSearchIndex();
  }

  async loadExamQuestions() {
    const examFiles = [
      'exam-5th.json',
      'exam-6th.json', 
      'exam-7th.json',
      'exam-8th.json',
      'exam-9th.json',
      'exam-10th.json',
      'exam-11th.json'
    ];

    let totalQuestions = 0;
    let successCount = 0;

    for (const file of examFiles) {
      try {
        const filePath = path.join(this.structuredDir, file);
        const fileExists = await fs.access(filePath).then(() => true).catch(() => false);
        
        if (!fileExists) {
          console.log(`‚ö†Ô∏è  ${file}: ÌååÏùº ÏóÜÏùå`);
          continue;
        }

        const data = JSON.parse(await fs.readFile(filePath, 'utf-8'));
        const examYear = parseInt(data.exam_year) || parseInt(file.match(/\d+/)[0]);
        
        if (data.questions && Array.isArray(data.questions)) {
          for (const q of data.questions) {
            if (q.question && q.question.trim()) {
              await this.insertQuestion(examYear, q);
              totalQuestions++;
            }
          }
          successCount++;
          console.log(`‚úÖ ${file}: ${data.questions.length}Í∞ú Î¨∏Ï†ú Î°úÎìú`);
        }
      } catch (error) {
        console.error(`‚ùå ${file} Î°úÎìú Ïã§Ìå®:`, error.message);
      }
    }

    // ÎßàÌÅ¨Îã§Ïö¥ ÌååÏùºÏóêÏÑú Ï∂îÍ∞Ä Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
    await this.loadFromMarkdownFiles();

    console.log(`\nüìä Ï¥ù ${totalQuestions}Í∞ú Î¨∏Ï†ú Î°úÎìú ÏôÑÎ£å (${successCount}Í∞ú ÌååÏùº)`);
  }

  async insertQuestion(examYear, questionData) {
    return new Promise((resolve, reject) => {
      const sql = `
        INSERT OR IGNORE INTO exam_questions (
          exam_year, exam_round, question_number, subject, 
          question_text, question_type, points, is_incomplete
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `;

      const params = [
        examYear,
        1, // ÌöåÏ∞®Îäî Î™®Îëê 1Ï∞® ÏãúÌóò
        questionData.number || 0,
        questionData.subject || 'ÎØ∏Î∂ÑÎ•ò',
        this.cleanQuestionText(questionData.question),
        'multiple_choice', // ÎåÄÎ∂ÄÎ∂Ñ Í∞ùÍ¥ÄÏãù
        1, // Í∏∞Î≥∏ Î∞∞Ï†ê
        questionData.is_incomplete ? 1 : 0
      ];

      this.db.run(sql, params, function(err) {
        if (err) {
          reject(err);
        } else {
          const questionId = this.lastID;
          
          // ÏÑ†ÌÉùÏßÄ ÏÇΩÏûÖ
          if (questionData.choices) {
            const choices = Object.entries(questionData.choices);
            choices.forEach(([num, text], index) => {
              const choiceSql = `
                INSERT OR IGNORE INTO exam_choices (
                  question_id, choice_number, choice_text, is_correct
                ) VALUES (?, ?, ?, ?)
              `;
              
              this.db.run(choiceSql, [
                questionId,
                index + 1,
                text,
                questionData.answer == num ? 1 : 0
              ]);
            });
          }

          // Ï†ïÎãµ Î∞è Ìï¥ÏÑ§ ÏÇΩÏûÖ
          if (questionData.answer || questionData.explanation) {
            const answerSql = `
              INSERT OR IGNORE INTO exam_answers (
                question_id, correct_answer, explanation
              ) VALUES (?, ?, ?)
            `;
            
            this.db.run(answerSql, [
              questionId,
              questionData.answer || '',
              questionData.explanation || ''
            ]);
          }

          // ÌÇ§ÏõåÎìú ÏÇΩÏûÖ
          if (questionData.keywords && Array.isArray(questionData.keywords)) {
            questionData.keywords.forEach(keyword => {
              const keywordSql = `
                INSERT OR IGNORE INTO exam_keywords (
                  question_id, keyword
                ) VALUES (?, ?)
              `;
              
              this.db.run(keywordSql, [questionId, keyword]);
            });
          }

          resolve(questionId);
        }
      }.bind(this));
    });
  }

  async loadFromMarkdownFiles() {
    console.log('\nüìÑ ÎßàÌÅ¨Îã§Ïö¥ ÌååÏùºÏóêÏÑú Ï∂îÍ∞Ä Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú...');
    
    const markdownFiles = [
      'exam-6th-final-150.md',
      'exam-7th-final-150.md',
      'exam-8th-final-150.md',
      'exam-9th-final-150.md',
      'exam-10th-final-150.md',
      'exam-11th-perfect.md'
    ];

    for (const file of markdownFiles) {
      try {
        const filePath = path.join(this.dataDir, file);
        const fileExists = await fs.access(filePath).then(() => true).catch(() => false);
        
        if (!fileExists) continue;

        const content = await fs.readFile(filePath, 'utf-8');
        const questions = this.parseMarkdownQuestions(content);
        
        if (questions.length > 0) {
          const examYear = parseInt(file.match(/\d+/)[0]);
          
          for (const q of questions) {
            await this.insertQuestion(examYear, q);
          }
          
          console.log(`‚úÖ ${file}: ${questions.length}Í∞ú Î¨∏Ï†ú Ï∂îÏ∂ú`);
        }
      } catch (error) {
        console.error(`‚ö†Ô∏è  ${file} Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò:`, error.message);
      }
    }
  }

  parseMarkdownQuestions(content) {
    const questions = [];
    const lines = content.split('\n');
    
    let currentQuestion = null;
    let inQuestion = false;
    let questionNumber = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Î¨∏Ï†ú ÏãúÏûë Ìå®ÌÑ¥ Ï∞æÍ∏∞
      if (line.match(/^(Î¨∏Ï†ú|##?\s*Î¨∏Ï†ú|##?\s*\d+\.|##?\s*\d+\)|##?\s*\[\d+\])/)) {
        if (currentQuestion && currentQuestion.question) {
          questions.push(currentQuestion);
        }
        
        questionNumber++;
        currentQuestion = {
          number: questionNumber,
          question: '',
          choices: {},
          subject: this.guessSubject(line)
        };
        inQuestion = true;
      } else if (inQuestion && currentQuestion) {
        // ÏÑ†ÌÉùÏßÄ Ìå®ÌÑ¥ Ï∞æÍ∏∞
        const choiceMatch = line.match(/^([‚ë†‚ë°‚ë¢‚ë£‚ë§]|[1-5][.)]\s*)/);
        if (choiceMatch) {
          const choiceNum = choiceMatch[0].replace(/[‚ë†‚ë°‚ë¢‚ë£‚ë§).\s]/g, '');
          const choiceText = line.substring(choiceMatch[0].length).trim();
          currentQuestion.choices[choiceNum] = choiceText;
        } else if (line.match(/^(Ï†ïÎãµ|Îãµ)\s*[:Ôºö]/)) {
          const answer = line.replace(/^(Ï†ïÎãµ|Îãµ)\s*[:Ôºö]\s*/, '').trim();
          currentQuestion.answer = answer;
          inQuestion = false;
        } else if (line && !line.startsWith('#')) {
          currentQuestion.question += ' ' + line;
        }
      }
    }

    // ÎßàÏßÄÎßâ Î¨∏Ï†ú Ï∂îÍ∞Ä
    if (currentQuestion && currentQuestion.question) {
      questions.push(currentQuestion);
    }

    return questions;
  }

  guessSubject(text) {
    const subjects = {
      'ÏàòÎ™©Î≥ëÎ¶¨': 'ÏàòÎ™©Î≥ëÎ¶¨Ìïô',
      'ÏàòÎ™©Ìï¥Ï∂©': 'ÏàòÎ™©Ìï¥Ï∂©Ìïô',
      'ÏàòÎ™©ÏÉùÎ¶¨': 'ÏàòÎ™©ÏÉùÎ¶¨Ìïô',
      'ÏàòÎ™©Í¥ÄÎ¶¨': 'ÏàòÎ™©Í¥ÄÎ¶¨Ìïô',
      'ÏûÑÏóÖ': 'ÏûÑÏóÖÏùºÎ∞ò',
      'ÌÜ†Ïñë': 'ÌÜ†ÏñëÌïô'
    };

    for (const [keyword, subject] of Object.entries(subjects)) {
      if (text.includes(keyword)) {
        return subject;
      }
    }

    return 'ÎØ∏Î∂ÑÎ•ò';
  }

  cleanQuestionText(text) {
    if (!text) return '';
    
    // Í∏∞Î≥∏ Ï†ïÎ¶¨
    let cleaned = text
      .replace(/\*\*Î¨∏Ï†ú\*\*:\s*/g, '')
      .replace(/\*\*ÌÇ§ÏõåÎìú\*\*:.*$/g, '')
      .replace(/---\s*##/g, '')
      .replace(/\s+/g, ' ')
      .trim();

    // OCR Ïò§Î•ò Ìå®ÌÑ¥ ÏàòÏ†ï
    const corrections = {
      'Î™¨ÎèÑ': 'Ïò®ÎèÑ',
      'ÎÆ§Ìö®': 'Ïú†Ìö®',
      'AES': 'Í≤ÉÏùÄ',
      'GALLS': 'Ìòπ',
      'HAMAS': 'DNAÎ•º',
      'SSes': 'ÏóêÏÑú',
      'Bay': 'ÏóºÏÉâ',
      'BIOS S': 'ÌîºÏñ¥Ïä§Î≥ë'
    };

    for (const [wrong, correct] of Object.entries(corrections)) {
      cleaned = cleaned.replace(new RegExp(wrong, 'g'), correct);
    }

    return cleaned;
  }

  async loadTextbookInfo() {
    console.log('\nüìñ ÍµêÏû¨ Ï†ïÎ≥¥ Î°úÎìú...');
    
    const textbookData = {
      subjects: [
        'ÏàòÎ™©Î≥ëÎ¶¨Ìïô',
        'ÏàòÎ™©Ìï¥Ï∂©Ìïô', 
        'ÏàòÎ™©ÏÉùÎ¶¨Ìïô',
        'ÏàòÎ™©Í¥ÄÎ¶¨Ìïô',
        'ÏûÑÏóÖÏùºÎ∞ò',
        'ÌÜ†ÏñëÌïô'
      ],
      metadata: {
        'ÏàòÎ™©Î≥ëÎ¶¨Ìïô': {
          topics: ['Î≥ëÏõêÏ≤¥', 'ÏßÑÎã®', 'Î∞©Ï†ú', 'ÏÑ∏Í∑†Î≥ë', 'Î∞îÏù¥Îü¨Ïä§Î≥ë', 'ÏßÑÍ∑†Î≥ë'],
          keywords: ['Î≥ëÏõêÏ≤¥', 'Í∞êÏóº', 'Î∞©Ï†ú', 'ÏÇ¥Í∑†Ï†ú', 'ÏßÑÎã®']
        },
        'ÏàòÎ™©Ìï¥Ï∂©Ìïô': {
          topics: ['Ìï¥Ï∂©Î∂ÑÎ•ò', 'ÌîºÌï¥ÏßÑÎã®', 'Î∞©Ï†úÎ≤ï', 'Ï≤úÏ†Å', 'ÏÇ¥Ï∂©Ï†ú'],
          keywords: ['Ìï¥Ï∂©', 'Ï≤úÏ†Å', 'Î∞©Ï†ú', 'ÏÇ¥Ï∂©Ï†ú', 'ÌîºÌï¥']
        },
        'ÏàòÎ™©ÏÉùÎ¶¨Ìïô': {
          topics: ['Í¥ëÌï©ÏÑ±', 'Ìò∏Ìù°', 'Ï¶ùÏÇ∞ÏûëÏö©', 'ÏòÅÏñë', 'ÏÉùÏû•'],
          keywords: ['Í¥ëÌï©ÏÑ±', 'Ìò∏Ìù°', 'ÏòÅÏñë', 'ÏÉùÏû•', 'Ïä§Ìä∏Î†àÏä§']
        },
        'ÏàòÎ™©Í¥ÄÎ¶¨Ìïô': {
          topics: ['Ï†ÑÏ†ï', 'ÏãúÎπÑ', 'Î≥ëÌï¥Ï∂©Í¥ÄÎ¶¨', 'ÌÜ†ÏñëÍ¥ÄÎ¶¨', 'ÏàòÎ™©ÏßÑÎã®'],
          keywords: ['Ï†ÑÏ†ï', 'ÏãúÎπÑ', 'Í¥ÄÎ¶¨', 'ÏßÑÎã®', 'ÌÜ†Ïñë']
        }
      }
    };

    // ÍµêÏû¨ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const sql = `
      INSERT OR REPLACE INTO textbooks (
        title, subject, file_path, page_count, created_at
      ) VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
    `;

    for (const subject of textbookData.subjects) {
      await new Promise((resolve, reject) => {
        this.db.run(sql, [
          `${subject} ÍµêÏû¨`,
          subject,
          `textbooks/${subject}.pdf`,
          300 // ÏòàÏÉÅ ÌéòÏù¥ÏßÄ Ïàò
        ], (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
    }

    console.log('‚úÖ ÍµêÏû¨ Ï†ïÎ≥¥ Î°úÎìú ÏôÑÎ£å');
  }

  async createSearchIndex() {
    console.log('\nüîç Í≤ÄÏÉâ Ïù∏Îç±Ïä§ ÏÉùÏÑ±...');
    
    // FTS ÌÖåÏù¥Î∏î ÏÉùÏÑ±
    const createFTS = `
      CREATE VIRTUAL TABLE IF NOT EXISTS exam_questions_fts USING fts5(
        question_text, subject, keywords,
        content=exam_questions, content_rowid=id
      );
    `;

    await new Promise((resolve, reject) => {
      this.db.run(createFTS, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });

    // FTS Ïù∏Îç±Ïä§ Ï±ÑÏö∞Í∏∞
    const populateFTS = `
      INSERT INTO exam_questions_fts (question_text, subject, keywords)
      SELECT 
        question_text,
        subject,
        (SELECT GROUP_CONCAT(keyword, ' ') FROM exam_keywords WHERE question_id = q.id)
      FROM exam_questions q;
    `;

    await new Promise((resolve, reject) => {
      this.db.run(populateFTS, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });

    console.log('‚úÖ Í≤ÄÏÉâ Ïù∏Îç±Ïä§ ÏÉùÏÑ± ÏôÑÎ£å');
  }

  async generateStatusReport() {
    console.log('\nüìä ÏÉÅÌÉú Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±...');
    
    const stats = await this.getStatistics();
    
    const report = {
      generated_at: new Date().toISOString(),
      database: {
        path: this.dbPath,
        size: await this.getFileSize(this.dbPath)
      },
      statistics: stats,
      setup_instructions: {
        step1: "npm install Ïã§Ìñâ",
        step2: "npm run setup Ïã§Ìñâ (Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏)",
        step3: "npm startÎ°ú MCP ÏÑúÎ≤Ñ ÏãúÏûë",
        step4: "Claude DesktopÏóêÏÑú MCP Ïó∞Í≤∞"
      }
    };

    await fs.writeFile(
      path.join(this.dataDir, 'setup-status.json'),
      JSON.stringify(report, null, 2)
    );

    console.log('‚úÖ ÏÉÅÌÉú Î¶¨Ìè¨Ìä∏ Ï†ÄÏû•: data/setup-status.json');
    console.log('\nüìà ÏµúÏ¢Ö ÌÜµÍ≥Ñ:');
    console.log(`- Ï¥ù Î¨∏Ï†ú Ïàò: ${stats.total_questions}`);
    console.log(`- Í≥ºÎ™© Ïàò: ${stats.subjects.length}`);
    console.log(`- ÌöåÏ∞®: ${stats.exam_years.join(', ')}Ìöå`);
  }

  async getStatistics() {
    return new Promise((resolve, reject) => {
      const sql = `
        SELECT 
          COUNT(*) as total_questions,
          COUNT(DISTINCT subject) as subject_count,
          COUNT(DISTINCT exam_year) as year_count
        FROM exam_questions
      `;

      this.db.get(sql, (err, row) => {
        if (err) {
          reject(err);
        } else {
          // Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏàòÏßë
          this.db.all('SELECT DISTINCT subject FROM exam_questions', (err2, subjects) => {
            this.db.all('SELECT DISTINCT exam_year FROM exam_questions ORDER BY exam_year', (err3, years) => {
              resolve({
                total_questions: row.total_questions,
                subjects: subjects.map(s => s.subject),
                exam_years: years.map(y => y.exam_year)
              });
            });
          });
        }
      });
    });
  }

  async getFileSize(filePath) {
    try {
      const stats = await fs.stat(filePath);
      return `${(stats.size / 1024 / 1024).toFixed(2)} MB`;
    } catch {
      return 'N/A';
    }
  }

  async close() {
    if (this.db) {
      this.db.close();
    }
  }
}

// Ïã§Ìñâ
async function main() {
  const setup = new TreeDoctorDataSetup();
  
  try {
    await setup.initialize();
    await setup.generateStatusReport();
    await setup.close();
    
    console.log('\nüéâ ÏÑ§Ï†ï ÏôÑÎ£å! Îã§Ïùå Î™ÖÎ†πÏúºÎ°ú MCP ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî:');
    console.log('   npm start\n');
  } catch (error) {
    console.error('\n‚ùå ÏÑ§Ï†ï Ï§ë Ïò§Î•ò Î∞úÏÉù:', error);
    process.exit(1);
  }
}

// package.jsonÏóê Ïä§ÌÅ¨Î¶ΩÌä∏ Ï∂îÍ∞Ä ÌïÑÏöî
// "scripts": {
//   "setup": "node scripts/setup-complete-data.js",
//   "start": "node dist/index.js"
// }

main();