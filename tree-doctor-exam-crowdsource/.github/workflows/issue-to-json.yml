name: Issue to JSON Converter

on:
  issues:
    types: [opened, edited]

jobs:
  convert:
    if: contains(github.event.issue.labels.*.name, 'new-question')
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
    
    - name: Parse Issue and Create JSON
      uses: actions/github-script@v6
      with:
        script: |
          const issue = context.issue;
          const body = context.payload.issue.body;
          
          // Parse issue body
          const parseIssue = (body) => {
            const lines = body.split('\n');
            const data = {
              verifiedBy: [],
              contributor: context.payload.issue.user.login
            };
            
            // Extract fields using regex
            const patterns = {
              year: /년도\**:\s*(\d{4})/,
              round: /회차\**:\s*(\d+)/,
              subject: /과목\**:\s*([^\n]+)/,
              questionNumber: /문제번호\**:\s*(\d+)/,
              question: /### 문제 내용\s*```\s*([^`]+)\s*```/,
              answer: /정답 번호\**:\s*(\d)/,
              explanation: /정답 설명\**[^:]*:\s*([^\n]+)/,
              difficulty: /난이도\**:\s*([상중하])/,
              image: /이미지 URL\**[^:]*:\s*([^\n]+)/,
              tags: /태그\**:\s*([^\n]+)/
            };
            
            // Extract basic info
            for (const [key, pattern] of Object.entries(patterns)) {
              const match = body.match(pattern);
              if (match) {
                if (key === 'year' || key === 'round' || key === 'questionNumber' || key === 'answer') {
                  data[key] = parseInt(match[1]);
                } else if (key === 'tags') {
                  data[key] = match[1].split(',').map(t => t.trim());
                } else {
                  data[key] = match[1].trim();
                }
              }
            }
            
            // Extract options
            const optionsMatch = body.match(/### 선택지\s*([\s\S]+?)### 정답/);
            if (optionsMatch) {
              const optionLines = optionsMatch[1].match(/[①②③④]\s*[^\n]+/g);
              data.options = optionLines ? optionLines.map(opt => opt.trim()) : [];
            }
            
            // Generate ID
            if (data.year && data.round && data.questionNumber) {
              data.id = `${data.year}-${data.round}-${String(data.questionNumber).padStart(3, '0')}`;
              data.source = `${data.year}년 제${data.round}회 나무의사 자격시험`;
            }
            
            return data;
          };
          
          try {
            const questionData = parseIssue(body);
            
            // Create branch
            const branch = `auto/issue-${issue.number}`;
            const baseBranch = 'main';
            
            // Get base branch reference
            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${baseBranch}`
            });
            
            // Create new branch
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/heads/${branch}`,
              sha: ref.object.sha
            });
            
            // Create file path
            const filePath = `data/${questionData.year}/round-${questionData.round}/${questionData.subject}/question-${String(questionData.questionNumber).padStart(3, '0')}.json`;
            const content = Buffer.from(JSON.stringify(questionData, null, 2)).toString('base64');
            
            // Create file
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: filePath,
              message: `add: ${questionData.year}년 ${questionData.round}회 ${questionData.subject} ${questionData.questionNumber}번`,
              content: content,
              branch: branch
            });
            
            // Create PR
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[자동생성] ${questionData.year}년 ${questionData.round}회 ${questionData.subject} ${questionData.questionNumber}번`,
              head: branch,
              base: baseBranch,
              body: `## 자동 생성된 PR\n\n이 PR은 Issue #${issue.number}에서 자동으로 생성되었습니다.\n\n### 문제 정보\n- ID: ${questionData.id}\n- 과목: ${questionData.subject}\n- 문제: ${questionData.question.substring(0, 50)}...\n\n### 검증 필요\n이 PR은 최소 2명의 검증이 필요합니다.\n\nCloses #${issue.number}`
            });
            
            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['needs-verification', 'auto-generated']
            });
            
            // Comment on issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `✅ PR이 자동으로 생성되었습니다: #${pr.number}\n\n검증이 완료되면 자동으로 병합됩니다.`
            });
            
          } catch (error) {
            // Error comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `❌ 자동 변환 실패\n\n에러: ${error.message}\n\n수동으로 PR을 생성해주세요.`
            });
          }